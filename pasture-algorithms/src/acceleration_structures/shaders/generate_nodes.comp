/*
Compute shader for processing octree nodes.
This approach is based on the work shown in "GPU-based Adaptive Octree Construction Algorithms" by (Goradia, 2008),
Global buffer indeces[] maps an index to a point of the point cloud.
This is used, so that we do not need to swap any real point inside the Point buffer.
We use the indices to later adress the correct points of a Pasture PointBuffer

Each node holds an array called node_partitioning, that specifies the range of indices a node contains.
node_partitioning: [4,9,12,12,20,22,26,30] points_per_partition: [4,5,3,0,8,2,4,4]

Right now, each parent in parents[] node has its own WorkGroup consisting of 8 threads, each thread assigning the computed
values to the corresponding child node in children[]. That means each block of 8 Nodes in children[] belongs to o Node in parents[].

*/

#version 450

struct Node {
  double bounds_min[3];
  double bounds_max[3];
  uint node_partitioning[8];
  uint points_per_partition[8];
  uint points_start;
  uint points_end;
};

layout(std430, set=0, binding=0) buffer ParentNodes{
  Node parents[];
};
layout(std430, set=0, binding=1) buffer ChildNodes{
  Node children[];
};
layout(std430, set=1, binding=0) buffer PointBuffer {
  double points[][3];
};
layout(std430, set=1, binding=1) buffer Partitioning {
  uint indeces[];
};

layout (local_size_x=8, local_size_y=1, local_size_z=1) in;

/// Determines the order in which the node is divided on is axes
/// [0,1,2] means partition order is x,y,z
uint[3] partitioning_order(double x, double y, double z){
  uint[] order = uint[3](0,1,2);
  double[] axes = double[3](x,y,z);
  for(uint i = 0; i < 2; ++i){
    if(axes[i] < axes[i+1]){
      uint tmp_order = order[i];
      double tmp_axis = axes[i];
      order[i] = order[i+1];
      axes[i] = axes[i+1];
      order[i+1] = tmp_order;
      axes[i+1] = tmp_axis;
    }
  }
  if(axes[0] < axes[1]){
    uint tmp = order[0];
    order[0] = order[1];
    order[1] = tmp;
  }
  return order;
}
/// Swaps the indices at place a and b
void swap( uint a,  uint b){
  uint tmp = indeces[a];
  indeces[a] = indeces[b];
  indeces[b] = tmp;
}

/// Partitions the indeces buffer along given axis with given pivot
/// When finished all points in [start, j) are less than pivot and all
/// points in [j, end) are greater equals pivot
uint partition_run(uint start, uint end, double pivot, uint axis) {
  uint i = start;
  uint j = start;

  while(i < end) {
    if(points[indeces[i]][axis] > pivot){
      ++i;
    }
    else if(points[indeces[i]][axis] <= pivot){
      swap(i, j);
      ++i;
      ++j;
    }
  }

  return j;
}
/// Starts the different partitionig phases for the axes
/// At the end half of node_partitioning (0-3) are below pivots[0] on axes[0],
/// (0-1) are below pivots[1] on axes[1] and (2-3) are above pivots[1] o axes[1]
/// (0) and (2) are below pivots[2] on axis[2], (1) and (3) are above pivots[2] on axis[2].
/// Same happens on subpartition (4-7) of node_partitioning
void partitioning(uint[3] axes, double[3] pivots, uint id, uint local_thread_id){
  uint start = parents[id].points_start;
  uint end = parents[id].node_partitioning[0];
  if(local_thread_id == 0){
    parents[id].node_partitioning[3] = partition_run(start, end, pivots[axes[0]], axes[0]);
  }
  barrier();
  if(local_thread_id == 1) {
    parents[id].node_partitioning[1] = partition_run(start, parents[id].node_partitioning[3], pivots[axes[1]], axes[1]);
  }
  else if(local_thread_id == 2){
    parents[id].node_partitioning[5] = partition_run(parents[id].node_partitioning[3], end, pivots[axes[1]], axes[1]);
  }
  barrier();
  if(local_thread_id == 3){
    parents[id].node_partitioning[0] = partition_run(start, parents[id].node_partitioning[1], pivots[axes[2]], axes[2]);
  }
  else if(local_thread_id == 4){
    parents[id].node_partitioning[2] = partition_run(parents[id].node_partitioning[1], parents[id].node_partitioning[3], pivots[axes[2]], axes[2]);
  }
  else if(local_thread_id == 5){
    parents[id].node_partitioning[4] = partition_run(parents[id].node_partitioning[3], parents[id].node_partitioning[5], pivots[axes[2]], axes[2]);
  }
  else if(local_thread_id == 6){
    parents[id].node_partitioning[6] = partition_run(parents[id].node_partitioning[5], end, pivots[axes[2]], axes[2]);
  }
  else if(local_thread_id == 7){
    parents[id].node_partitioning[7] = end;
  }
  barrier();
}

/// Returns if child at `index` in parent is partitioned on the right side of the pivot on any axis
bool[3] partitioned_to_right(uint[3] partition_order, uint index){
  bool[3] on_right_side = bool[3](false, false, false);

  on_right_side[partition_order[2]] = index % 2 != 0;
  on_right_side[partition_order[1]] = index >= 2 && index <= 3 || index >= 6;
  on_right_side[partition_order[0]] = index >= 4;
  return on_right_side;
}
/// Calculates the Bounding Box of given child
double[2][3] get_childs_bounds(uint[3] partition_order, double[3] partition_axes, uint child_index, Node parent){
  double[3] bounds_min;
  double[3] bounds_max;
  if(child_index == 0) {
    bounds_min = parent.bounds_min;
    bounds_max = partition_axes;
    return double[2][3](bounds_min, bounds_max);
  }
  bool[3] on_right_side = partitioned_to_right(partition_order, child_index);
  for(uint k = 0; k < 3; ++k){
    bounds_min[k] = on_right_side[k] ? partition_axes[k] : parent.bounds_min[k];
    bounds_max[k] = on_right_side[k] ? parent.bounds_max[k] : partition_axes[k];
  }
  return double[2][3](bounds_min, bounds_max);
}

void main() {
  uint idx = gl_WorkGroupID.x;
  uint thread_idx = gl_LocalInvocationID.x;
  Node parent = parents[idx];
  // Calculation of axis-length and center point coorddinates 
  // of parent's bounding box
  double x_diff = parent.bounds_max[0] - parent.bounds_min[0];
  double y_diff = parent.bounds_max[1] - parent.bounds_min[1];
  double z_diff = parent.bounds_max[2] - parent.bounds_min[2];
  double x_partition = parent.bounds_min[0] + 0.5 * abs(x_diff);
  double y_partition = parent.bounds_min[1] + 0.5 * abs(y_diff);
  double z_partition = parent.bounds_min[2] + 0.5 * abs(z_diff);
  double[3] partition_pivots = double[3](x_partition, y_partition, z_partition);
  uint[3] partition_order = partitioning_order(abs(x_diff), abs(y_diff), abs(z_diff));
  
  partitioning(partition_order, partition_pivots, idx, thread_idx);
  
  if(thread_idx == 0) {
    parents[idx].points_per_partition[thread_idx] = parents[idx].node_partitioning[thread_idx] - parents[idx].points_start;
  } 
  else {
   parents[idx].points_per_partition[thread_idx] = parents[idx].node_partitioning[thread_idx] - parents[idx].node_partitioning[thread_idx - 1];
  }
  // writes computed data into children
  // based on the number of points belonging to a child, we can
  // decide if the child is a leaf or should be processed as parent in next compute pass
  if(thread_idx == 0) {
    children[idx * 8 + thread_idx].points_start = parents[idx].points_start;
  } else {
    children[idx * 8 + thread_idx].points_start = parents[idx].node_partitioning[thread_idx - 1];
  }
  children[idx * 8 + thread_idx].points_per_partition[0] = parents[idx].points_per_partition[thread_idx];
  children[idx * 8 + thread_idx].points_end = parents[idx].node_partitioning[thread_idx];
  children[idx * 8 + thread_idx].node_partitioning[0] = children[idx * 8 + thread_idx].points_end;
  double[2][3] child_bounds = get_childs_bounds(
    partition_order,
    double[3](x_partition, y_partition, z_partition),
    thread_idx,
    parent
  );
  children[idx * 8 + thread_idx].bounds_min = child_bounds[0];
  children[idx* 8 + thread_idx].bounds_max = child_bounds[1];
}
